) %>% ungroup
#these are the denominators for each part
denominators = map_dbl(1:nrow(eq_parts)-1,~nfact*(ncol(combn(nfact-1,.))))
#extract all the data for each F() calculation
#one is for when alpha is from pop1, and one when alpha is from pop2
allperms <- allperms %>% as_tibble %>%
mutate(
data=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(facti,allperms[.,1:((length(allfacts)/2)-1)])]]),
data1=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(paste0(facti,1),allperms[.,1:((length(allfacts)/2)-1)])]])
)
#this is to clean up the 1s. Again, this aspect could be a lot better...
colClean <- function(x){ colnames(x) <- gsub("1", "", colnames(x)); x }
#Now we map the rate function (user defined) onto the data.
allperms %>% mutate(
data_rn = map(data,colClean),
rfunct = map(data_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf)),
data1_rn = map(data1,colClean),
rfunct1 = map(data1_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf))
) %>% select(-c(data,data_rn,cMs,data1,data1_rn)) -> allperms
#spread, unnest
feq_data = allperms %>% select(f_id, rfunct) %>% spread(f_id,rfunct) %>% unnest
feq_data1 = allperms %>% select(f_id, rfunct1) %>% spread(f_id,rfunct1) %>% unnest
eq_parts %>%
mutate(
top_part = map(F_eqs, ~select(feq_data,.) %>% rowSums),
top_part1 = map(F_eqs, ~select(feq_data1,.) %>% rowSums),
bottom_part = denominators,
eq = map2(top_part,bottom_part,~(.x/.y)),
eq1 = map2(top_part1,bottom_part,~(.x/.y))
) -> eq_parts
pop1=eq_parts %>% select(eq1) %>% unlist(recursive = F) %>% as_tibble() %>% rowSums
pop2=eq_parts %>% select(eq) %>% unlist(recursive = F) %>% as_tibble() %>% rowSums
diff=pop1-pop2
tibble(
!!paste0("pop",df2 %>% pull({{pop}}) %>% .[1] %>% as.character):=pop1,
!!paste0("pop",df2 %>% pull({{pop}}) %>% .[2] %>% as.character):=pop2,
factoreffect=diff
)
}
map(1:nfact,~DGadjust_ratefactor(df_nested,year,.,factrs,prodrf))
names(pop_facts)
pop_facts[allfacts[allfacts %in% c("prev",allperms[.,1:((length(allfacts)/2)-1)])]]
pop_facts[allfacts[allfacts %in% c("prev",allperms[1,1:((length(allfacts)/2)-1)])]]
[allfacts[allfacts %in% c("prev",allperms[1,1:((length(allfacts)/2)-1)])]]
allfacts[allfacts %in% c("prev",allperms[1,1:((length(allfacts)/2)-1)])]
c("prev",allperms[1,1:((length(allfacts)/2)-1)])
allperms[1,1:((length(allfacts)/2)-1)]
allperms[1,1:((length(allfacts)/2)-1)] %>% unlist
require(tidyverse)
data(reconv)
reconv %>% mutate(
iv=sort(round(runif(130,400,1000)),decreasing = T)+round(runif(130,1,10)),
prev=reconvicted/offenders,
age_str=offenders/convicted_population,
tiv=iv/convicted_population,
) -> reconv2
list.files("R/")
source(list.files("R/"))
source(list.files("R/",full.names = T))
list.files("R/",full.names = T)
source(list.files("R",full.names = T))
list.files("R",full.names = T)
map(list.files("R",full.names=T),source)
DasGupt_Npop(reconv2,pop=year,
prev,age_str,tiv,
id_vars=c(Sex,Age)) -> dgd
DasGupt_Npop(reconv2,pop=year,
prev,age_str,
id_vars=c(Sex,Age)) -> dgd
head(dgd)
factrs=c("prev","age_str","tiv")
filter(reconv2,year<=2005) %>%
group_by(year) %>%
nest() %>%
mutate(
factor_df = map(data, magrittr::extract,factrs)
) -> df_nested
prodrf=paste(factrs,collapse="*")
nfact=3
map(1:nfact,~DGadjust_ratefactor(df_nested,year,.,factrs,prodrf))
i=1
df2<-df_nested
pop_facts<-df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest()
pop_facts<-df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest()
allfacts=names(pop_facts)
allfacts
allfacts0 = allfacts[1:nfact]
allfacts1 = allfacts[(nfact+1):length(allfacts)]
#these are the all the combinations of P-1 factors from 2 populations
allperms<-tibble(perms=combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t)
facti=factrs[i]
#these are the all the combinations of P-1 factors from 2 populations
allperms<-tibble(perms=combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t)
allperms
#because we need to distinguish between sets by how many are from pop1 and how many from pop2, we'll count the 1s and absence of 1s
# we also need to remove any sets in which factors come up twice (e.g. age_str and age_str1)
count1s <- apply(allperms, 1, function(x) length(which(x %in% allfacts1)))
count0s <- apply(allperms, 1, function(x) length(which(x %in% allfacts0)))
countmult <- apply(data.frame(lapply(allperms, function(x) {gsub("1","",x)})), 1, function(x) sum(duplicated(x)|duplicated(x, fromLast = TRUE)))
allperms %>% mutate(
#c0s=ifelse(count0s %in% c(0,(length(allfacts)/2-1)),0,count0s),
#c1s=ifelse(count1s %in% c(0,(length(allfacts)/2-1)),0,count1s),
eqp=map_dfc(0:floor(nfact/2),~ifelse(count0s==.|count1s==.,.,0)) %>% rowSums,
cMs=countmult
) %>% filter(cMs==0) -> allperms
#make an id for each
allperms$f_id<-paste0("f",1:nrow(allperms))
allperms
allperms %>% group_by(eqp) %>%
summarise(
n=n(),
F_eqs=list(f_id)
) %>% ungroup
#these are the parts of the DG 3.54 equation (page 32)
eq_parts <- allperms %>% group_by(eqp) %>%
summarise(
n=n(),
F_eqs=list(f_id)
) %>% ungroup
#these are the denominators for each part
denominators = map_dbl(1:nrow(eq_parts)-1,~nfact*(ncol(combn(nfact-1,.))))
map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(facti,allperms[.,1:((length(allfacts)/2)-1)])]])
allfacts
c(facti,allperms[.,1:((length(allfacts)/2)-1)])
allperms[1,1:((length(allfacts)/2)-1)]
allperms
1:((length(allfacts)/2)-1)
allperms[1,1:((length(allfacts)/2)-1)]
allperms[1,1:2]
allperms[,1:2]
names(allperms)
allperms
allperms
tibble(perms=combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t)
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t
tibble(combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t)
#these are the all the combinations of P-1 factors from 2 populations
allperms<-tibble(perms=combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t)
str(allperms)
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as_tibble(.)
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as_tibble(.,.name_repair="universal")
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as_tibble(.,.name_repair="minimal")
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as_tibble(.,.name_repair="unique")
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as.data.frame()
#these are the all the combinations of P-1 factors from 2 populations
allperms<-combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as.data.frame()
#because we need to distinguish between sets by how many are from pop1 and how many from pop2, we'll count the 1s and absence of 1s
# we also need to remove any sets in which factors come up twice (e.g. age_str and age_str1)
count1s <- apply(allperms, 1, function(x) length(which(x %in% allfacts1)))
count0s <- apply(allperms, 1, function(x) length(which(x %in% allfacts0)))
countmult <- apply(data.frame(lapply(allperms, function(x) {gsub("1","",x)})), 1, function(x) sum(duplicated(x)|duplicated(x, fromLast = TRUE)))
allperms %>% mutate(
#c0s=ifelse(count0s %in% c(0,(length(allfacts)/2-1)),0,count0s),
#c1s=ifelse(count1s %in% c(0,(length(allfacts)/2-1)),0,count1s),
eqp=map_dfc(0:floor(nfact/2),~ifelse(count0s==.|count1s==.,.,0)) %>% rowSums,
cMs=countmult
) %>% filter(cMs==0) -> allperms
#make an id for each
allperms$f_id<-paste0("f",1:nrow(allperms))
allperms
#these are the parts of the DG 3.54 equation (page 32)
eq_parts <- allperms %>% group_by(eqp) %>%
summarise(
n=n(),
F_eqs=list(f_id)
) %>% ungroup
#these are the denominators for each part
denominators = map_dbl(1:nrow(eq_parts)-1,~nfact*(ncol(combn(nfact-1,.))))
allperms %>% as_tibble %>%
mutate(
data=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(facti,allperms[.,1:((length(allfacts)/2)-1)])]]),
data1=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(paste0(facti,1),allperms[.,1:((length(allfacts)/2)-1)])]])
)
require(tidyverse)
data(reconv)
map(list.files("R",full.names=T),source)
reconv %>% mutate(
iv=sort(round(runif(130,400,1000)),decreasing = T)+round(runif(130,1,10)),
prev=reconvicted/offenders,
age_str=offenders/convicted_population,
tiv=iv/convicted_population,
) -> reconv2
DasGupt_Npop(reconv2,pop=year,
prev,age_str,tiv,
id_vars=c(Sex,Age)) -> dgd
factrs=c("prev","age_str","tiv")
filter(reconv2,year<=2005) %>%
group_by(year) %>%
nest() %>%
mutate(
factor_df = map(data, magrittr::extract,factrs)
) -> df_nested
prodrf=paste(factrs,collapse="*")
nfact=3
map(1:nfact,~DGadjust_ratefactor(df_nested,year,.,factrs,prodrf))
i=1
facti=factrs[i]
df2<-df_nested
pop_facts<-df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest()
allfacts=names(pop_facts)
allfacts0 = allfacts[1:nfact]
allfacts1 = allfacts[(nfact+1):length(allfacts)]
#these are the all the combinations of P-1 factors from 2 populations
allperms<-combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as.data.frame()
allperms
#because we need to distinguish between sets by how many are from pop1 and how many from pop2, we'll count the 1s and absence of 1s
# we also need to remove any sets in which factors come up twice (e.g. age_str and age_str1)
count1s <- apply(allperms, 1, function(x) length(which(x %in% allfacts1)))
count1s
apply(allperms, 1, function(x) length(which(x %in% allfacts0)))
apply(data.frame(lapply(allperms, function(x) {gsub("1","",x)})), 1, function(x) sum(duplicated(x)|duplicated(x, fromLast = TRUE)))
allperms %>% mutate(
#c0s=ifelse(count0s %in% c(0,(length(allfacts)/2-1)),0,count0s),
#c1s=ifelse(count1s %in% c(0,(length(allfacts)/2-1)),0,count1s),
eqp=map_dfc(0:floor(nfact/2),~ifelse(count0s==.|count1s==.,.,0)) %>% rowSums,
cMs=countmult
) %>% filter(cMs==0) -> allperms
#because we need to distinguish between sets by how many are from pop1 and how many from pop2, we'll count the 1s and absence of 1s
# we also need to remove any sets in which factors come up twice (e.g. age_str and age_str1)
count1s <- apply(allperms, 1, function(x) length(which(x %in% allfacts1)))
count0s <- apply(allperms, 1, function(x) length(which(x %in% allfacts0)))
countmult <- apply(data.frame(lapply(allperms, function(x) {gsub("1","",x)})), 1, function(x) sum(duplicated(x)|duplicated(x, fromLast = TRUE)))
allperms %>% mutate(
#c0s=ifelse(count0s %in% c(0,(length(allfacts)/2-1)),0,count0s),
#c1s=ifelse(count1s %in% c(0,(length(allfacts)/2-1)),0,count1s),
eqp=map_dfc(0:floor(nfact/2),~ifelse(count0s==.|count1s==.,.,0)) %>% rowSums,
cMs=countmult
) %>% filter(cMs==0) -> allperms
allperms
#make an id for each
allperms$f_id<-paste0("f",1:nrow(allperms))
#these are the parts of the DG 3.54 equation (page 32)
eq_parts <- allperms %>% group_by(eqp) %>%
summarise(
n=n(),
F_eqs=list(f_id)
) %>% ungroup
#these are the denominators for each part
denominators = map_dbl(1:nrow(eq_parts)-1,~nfact*(ncol(combn(nfact-1,.))))
#extract all the data for each F() calculation
#one is for when alpha is from pop1, and one when alpha is from pop2
allperms <- allperms %>% as_tibble %>%
mutate(
data=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(facti,allperms[.,1:((length(allfacts)/2)-1)])]]),
data1=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(paste0(facti,1),allperms[.,1:((length(allfacts)/2)-1)])]])
)
allperms[,1:2]
#this is to clean up the 1s. Again, this aspect could be a lot better...
colClean <- function(x){ colnames(x) <- gsub("1", "", colnames(x)); x }
#Now we map the rate function (user defined) onto the data.
allperms %>% mutate(
data_rn = map(data,colClean),
rfunct = map(data_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf)),
data1_rn = map(data1,colClean),
rfunct1 = map(data1_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf))
) %>% select(-c(data,data_rn,cMs,data1,data1_rn)) -> allperms
prodrf=paste(factrs,collapse="*")
#Now we map the rate function (user defined) onto the data.
allperms %>% mutate(
data_rn = map(data,colClean),
rfunct = map(data_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf)),
data1_rn = map(data1,colClean),
rfunct1 = map(data1_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf))
) %>% select(-c(data,data_rn,cMs,data1,data1_rn)) -> allperms
ratefunction=prodrf
#Now we map the rate function (user defined) onto the data.
allperms %>% mutate(
data_rn = map(data,colClean),
rfunct = map(data_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf)),
data1_rn = map(data1,colClean),
rfunct1 = map(data1_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf))
) %>% select(-c(data,data_rn,cMs,data1,data1_rn)) -> allperms
allperms %>% mutate(
data_rn = map(data,colClean),
#rfunct = map(data_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf)),
#data1_rn = map(data1,colClean),
#rfunct1 = map(data1_rn,~mutate(.,rf=eval(parse(text=ratefunction))) %>% pull(rf))
)
allperms
allperms$data[1]
map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(facti,allperms[.,1:((length(allfacts)/2)-1)])]])
1:nrow(allperms)
pop_facts
allfacts
allfacts[allfacts %in% c(facti,allperms[1,1:((length(allfacts)/2)-1)])]
allperms[1,1:((length(allfacts)/2)-1)]
c(facti,allperms[1,1:((length(allfacts)/2)-1)])
allperms[.,1:((length(allfacts)/2)-1)]
map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(paste0(facti,1),allperms[.,1:((length(allfacts)/2)-1)])]])
allperms[1,1:((length(allfacts)/2)-1)]
allperms
allperms[1,1:((length(allfacts)/2)-1)] %>% as.character
?as.data.frame
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as.data.frame(.,stringsAsFactors=FALSE)
combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as.data.frame(.,stringsAsFactors=FALSE) %>% str
#these are the all the combinations of P-1 factors from 2 populations
allperms<-combn(allfacts[!(allfacts %in% c(facti,paste0(facti,1)))],length(allfacts)/2-1) %>% t %>% as.data.frame(.,stringsAsFactors=FALSE)
#because we need to distinguish between sets by how many are from pop1 and how many from pop2, we'll count the 1s and absence of 1s
# we also need to remove any sets in which factors come up twice (e.g. age_str and age_str1)
count1s <- apply(allperms, 1, function(x) length(which(x %in% allfacts1)))
count0s <- apply(allperms, 1, function(x) length(which(x %in% allfacts0)))
countmult <- apply(data.frame(lapply(allperms, function(x) {gsub("1","",x)})), 1, function(x) sum(duplicated(x)|duplicated(x, fromLast = TRUE)))
allperms %>% mutate(
#c0s=ifelse(count0s %in% c(0,(length(allfacts)/2-1)),0,count0s),
#c1s=ifelse(count1s %in% c(0,(length(allfacts)/2-1)),0,count1s),
eqp=map_dfc(0:floor(nfact/2),~ifelse(count0s==.|count1s==.,.,0)) %>% rowSums,
cMs=countmult
) %>% filter(cMs==0) -> allperms
#make an id for each
allperms$f_id<-paste0("f",1:nrow(allperms))
#these are the parts of the DG 3.54 equation (page 32)
eq_parts <- allperms %>% group_by(eqp) %>%
summarise(
n=n(),
F_eqs=list(f_id)
) %>% ungroup
#these are the denominators for each part
denominators = map_dbl(1:nrow(eq_parts)-1,~nfact*(ncol(combn(nfact-1,.))))
#extract all the data for each F() calculation
#one is for when alpha is from pop1, and one when alpha is from pop2
allperms <- allperms %>% as_tibble %>%
mutate(
data=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(facti,allperms[.,1:((length(allfacts)/2)-1)])]]),
data1=map(1:nrow(allperms),~pop_facts[allfacts[allfacts %in% c(paste0(facti,1),allperms[.,1:((length(allfacts)/2)-1)])]])
)
allperms
require(tidyverse)
data(reconv)
map(list.files("R",full.names=T),source)
reconv %>% mutate(
iv=sort(round(runif(130,400,1000)),decreasing = T)+round(runif(130,1,10)),
prev=reconvicted/offenders,
age_str=offenders/convicted_population,
tiv=iv/convicted_population,
) -> reconv2
DasGupt_Npop(reconv2,pop=year,
prev,age_str,tiv,
id_vars=c(Sex,Age)) -> dgd
warnings()
?unchop
factrs=c("prev","age_str","tiv")
filter(reconv2,year<=2005) %>%
group_by(year) %>%
nest() %>%
mutate(
factor_df = map(data, magrittr::extract,factrs)
) -> df_nested
prodrf=paste(factrs,collapse="*")
nfact=3
map(1:nfact,~DGadjust_ratefactor(df_nested,year,.,factrs,prodrf))
i=1
facti=factrs[i]
df2<-df_nested
pop_facts<-df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest()
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unchop()
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest_wider()
?unnest_wider
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest_wider(.)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
df2 %>% dplyr::select(year,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% unnest_wider(.,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest()
df2 %>% dplyr::select(year,factor_df)
df2 %>% dplyr::select(factor_df) %>% unnest_wider(.,factor_df)
df2 %>% ungroup %>% dplyr::select(factor_df) %>% unnest_wider(.,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest_wider(.,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest(.,one_of(distinct(df2,{{pop}})))
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest(.,one_of(distinct(df2,year)))
distinct(df2,year)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest(.,one_of(as.character(distinct(df2,year))))
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest()
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
df2
df2$data[1]
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
?hoist
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(col="prev")
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(col=prev)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(.,col=prev)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(.,prev)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist()
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(.,col=`2004`,prev)
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(.,col=`2004`,"prev")
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% hoist(.,col="`2004`","prev")
df2
df2 %>% hoist(.,col=factor_df,"prev")
df2$factor_df[1]
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest(.,cols=c(`2004`, `2005`))
df2 %>% dplyr::select(year,factor_df) %>% spread(year,factor_df) %>% unnest_legacy()
require(tidyverse)
data(reconv)
map(list.files("R",full.names=T),source)
reconv %>% mutate(
iv=sort(round(runif(130,400,1000)),decreasing = T)+round(runif(130,1,10)),
prev=reconvicted/offenders,
age_str=offenders/convicted_population,
tiv=iv/convicted_population,
) -> reconv2
DasGupt_Npop(reconv2,pop=year,
prev,age_str,tiv,
id_vars=c(Sex,Age)) -> dgd
require(tidyverse)
data(reconv)
map(list.files("R",full.names=T),source)
reconv %>% mutate(
iv=sort(round(runif(130,400,1000)),decreasing = T)+round(runif(130,1,10)),
prev=reconvicted/offenders,
age_str=offenders/convicted_population,
tiv=iv/convicted_population,
) -> reconv2
DasGupt_Npop(reconv2,pop=year,
prev,age_str,tiv,
id_vars=c(Sex,Age)) -> dgd
reconv2
reconv2 %>%
mutate(
cr=prev*age_str*tiv
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
) %>% mutate(population=as.character(year)) %>% select(-year)
reconv2 %>%
mutate(
rate=prev*age_str*tiv
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
) %>% mutate(population=as.character(year)) %>% select(-year)
reconv2 %>%
mutate(
rate=prev*age_str*tiv
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
) %>% mutate(population=as.character(year)) %>% select(-year) %>%
ggplot(.,aes(x=population,y=rate))+geom_path()
reconv2 %>%
mutate(
rate=prev*age_str*tiv
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
) %>% mutate(population=as.character(year)) %>% select(-year)
reconv2 %>%
mutate(
rate=prev*age_str*tiv
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
) %>% mutate(population=as.character(year)) %>% #select(-year) %>%
ggplot(.,aes(x=year,y=rate))+geom_path()
reconv2 %>%
mutate(
rate=prev*age_str
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
) %>% mutate(population=as.character(year)) %>% #select(-year) %>%
ggplot(.,aes(x=year,y=rate))+geom_path()
DasGupt_rates(dgd)
DasGupt_rates(dgd) %>%
mutate(year=as.numeric(population)) %>%
ggplot(.,aes(x=year,y=rate,col=factor))+geom_path()
reconv2 %>%
mutate(
rate=prev*age_str*tiv
) %>% group_by(year) %>%
summarise(
rate=sum(rate),
factor="crude"
)
DasGupt_rates(dgd) %>%
mutate(year=as.numeric(population))
DasGupt_rates(dgd) %>%
mutate(year=as.numeric(population)) -> test1
DasGupt_Npop(reconv2,pop=year,
prev,age_str,
id_vars=c(Sex,Age)) -> dgd
DasGupt_rates(dgd) %>%
mutate(year=as.numeric(population))
test1
require(devtools)
require(roxygen2)
document()
('unnest_legacy' %in% ls('package:tidyr'))
require(tidyverse)
('unnest_legacy' %in% ls('package:tidyr'))
if('unnest_legacy' %in% ls('package:tidyr'))
{print(2)}
ls('package::tidyr')
ls('package:tidyr')
exits("unnest_legacy",mode="function")
exists("unnest_legacy",mode="function")
require(tidyverse)
exists("unnest_legacy",mode="function")
exists("unnest_legacy",where="package:tidyr",mode="function")
require(devtools)
require(roxygen2)
document()
